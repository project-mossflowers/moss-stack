// This file is auto-generated by @hey-api/openapi-ts

import {
  
  
  
  infiniteQueryOptions,
  queryOptions
} from '@tanstack/react-query'
import {
  
  authLoginAccessToken,
  authRecoverPassword,
  authRecoverPasswordHtmlContent,
  authResetPassword,
  authTestToken,
  itemsCreateItem,
  itemsDeleteItem,
  itemsReadItem,
  itemsReadItems,
  itemsUpdateItem,
  privateCreateUser,
  systemHealthCheck,
  usersCreateUser,
  usersDeleteUser,
  usersDeleteUserMe,
  usersReadUserById,
  usersReadUserMe,
  usersReadUsers,
  usersRegisterUser,
  usersUpdatePasswordMe,
  usersUpdateUser,
  usersUpdateUserMe
} from '../sdk.gen'
import { client as _heyApiClient } from '../client.gen'
import type {DefaultError, InfiniteData, UseMutationOptions} from '@tanstack/react-query';
import type {Options} from '../sdk.gen';
import type {
  AuthLoginAccessTokenData,
  AuthLoginAccessTokenError,
  AuthLoginAccessTokenResponse,
  AuthRecoverPasswordData,
  AuthRecoverPasswordError,
  AuthRecoverPasswordHtmlContentData,
  AuthRecoverPasswordHtmlContentError,
  AuthRecoverPasswordHtmlContentResponse,
  AuthRecoverPasswordResponse,
  AuthResetPasswordData,
  AuthResetPasswordError,
  AuthResetPasswordResponse,
  AuthTestTokenData,
  AuthTestTokenResponse,
  ItemsCreateItemData,
  ItemsCreateItemError,
  ItemsCreateItemResponse,
  ItemsDeleteItemData,
  ItemsDeleteItemError,
  ItemsDeleteItemResponse,
  ItemsReadItemData,
  ItemsReadItemsData,
  ItemsReadItemsError,
  ItemsReadItemsResponse,
  ItemsUpdateItemData,
  ItemsUpdateItemError,
  ItemsUpdateItemResponse,
  PrivateCreateUserData,
  PrivateCreateUserError,
  PrivateCreateUserResponse,
  SystemHealthCheckData,
  UsersCreateUserData,
  UsersCreateUserError,
  UsersCreateUserResponse,
  UsersDeleteUserData,
  UsersDeleteUserError,
  UsersDeleteUserMeData,
  UsersDeleteUserMeResponse,
  UsersDeleteUserResponse,
  UsersReadUserByIdData,
  UsersReadUserMeData,
  UsersReadUsersData,
  UsersRegisterUserData,
  UsersRegisterUserError,
  UsersRegisterUserResponse,
  UsersUpdatePasswordMeData,
  UsersUpdatePasswordMeError,
  UsersUpdatePasswordMeResponse,
  UsersUpdateUserData,
  UsersUpdateUserError,
  UsersUpdateUserMeData,
  UsersUpdateUserMeError,
  UsersUpdateUserMeResponse,
  UsersUpdateUserResponse,
} from '../types.gen'
import type { AxiosError } from 'axios'

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, 'baseURL' | 'body' | 'headers' | 'path' | 'query'> & {
    _id: string
    _infinite?: boolean
  },
]

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean,
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseURL:
      options?.baseURL ||
      (options?.client ?? _heyApiClient).getConfig().baseURL,
  } as QueryKey<TOptions>[0]
  if (infinite) {
    params._infinite = infinite
  }
  if (options?.body) {
    params.body = options.body
  }
  if (options?.headers) {
    params.headers = options.headers
  }
  if (options?.path) {
    params.path = options.path
  }
  if (options?.query) {
    params.query = options.query
  }
  return [params]
}

export const authLoginAccessTokenQueryKey = (
  options: Options<AuthLoginAccessTokenData>,
) => createQueryKey('authLoginAccessToken', options)

/**
 * Login Access Token
 * OAuth2 compatible token login, get an access token for future requests
 */
export const authLoginAccessTokenOptions = (
  options: Options<AuthLoginAccessTokenData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await authLoginAccessToken({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: authLoginAccessTokenQueryKey(options),
  })
}

/**
 * Login Access Token
 * OAuth2 compatible token login, get an access token for future requests
 */
export const authLoginAccessTokenMutation = (
  options?: Partial<Options<AuthLoginAccessTokenData>>,
): UseMutationOptions<
  AuthLoginAccessTokenResponse,
  AxiosError<AuthLoginAccessTokenError>,
  Options<AuthLoginAccessTokenData>
> => {
  const mutationOptions: UseMutationOptions<
    AuthLoginAccessTokenResponse,
    AxiosError<AuthLoginAccessTokenError>,
    Options<AuthLoginAccessTokenData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await authLoginAccessToken({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const authTestTokenQueryKey = (options?: Options<AuthTestTokenData>) =>
  createQueryKey('authTestToken', options)

/**
 * Test Token
 * Test access token
 */
export const authTestTokenOptions = (options?: Options<AuthTestTokenData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await authTestToken({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: authTestTokenQueryKey(options),
  })
}

/**
 * Test Token
 * Test access token
 */
export const authTestTokenMutation = (
  options?: Partial<Options<AuthTestTokenData>>,
): UseMutationOptions<
  AuthTestTokenResponse,
  AxiosError<DefaultError>,
  Options<AuthTestTokenData>
> => {
  const mutationOptions: UseMutationOptions<
    AuthTestTokenResponse,
    AxiosError<DefaultError>,
    Options<AuthTestTokenData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await authTestToken({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const authRecoverPasswordQueryKey = (
  options: Options<AuthRecoverPasswordData>,
) => createQueryKey('authRecoverPassword', options)

/**
 * Recover Password
 * Password Recovery
 */
export const authRecoverPasswordOptions = (
  options: Options<AuthRecoverPasswordData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await authRecoverPassword({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: authRecoverPasswordQueryKey(options),
  })
}

/**
 * Recover Password
 * Password Recovery
 */
export const authRecoverPasswordMutation = (
  options?: Partial<Options<AuthRecoverPasswordData>>,
): UseMutationOptions<
  AuthRecoverPasswordResponse,
  AxiosError<AuthRecoverPasswordError>,
  Options<AuthRecoverPasswordData>
> => {
  const mutationOptions: UseMutationOptions<
    AuthRecoverPasswordResponse,
    AxiosError<AuthRecoverPasswordError>,
    Options<AuthRecoverPasswordData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await authRecoverPassword({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const authResetPasswordQueryKey = (
  options: Options<AuthResetPasswordData>,
) => createQueryKey('authResetPassword', options)

/**
 * Reset Password
 * Reset password
 */
export const authResetPasswordOptions = (
  options: Options<AuthResetPasswordData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await authResetPassword({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: authResetPasswordQueryKey(options),
  })
}

/**
 * Reset Password
 * Reset password
 */
export const authResetPasswordMutation = (
  options?: Partial<Options<AuthResetPasswordData>>,
): UseMutationOptions<
  AuthResetPasswordResponse,
  AxiosError<AuthResetPasswordError>,
  Options<AuthResetPasswordData>
> => {
  const mutationOptions: UseMutationOptions<
    AuthResetPasswordResponse,
    AxiosError<AuthResetPasswordError>,
    Options<AuthResetPasswordData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await authResetPassword({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const authRecoverPasswordHtmlContentQueryKey = (
  options: Options<AuthRecoverPasswordHtmlContentData>,
) => createQueryKey('authRecoverPasswordHtmlContent', options)

/**
 * Recover Password Html Content
 * HTML Content for Password Recovery
 */
export const authRecoverPasswordHtmlContentOptions = (
  options: Options<AuthRecoverPasswordHtmlContentData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await authRecoverPasswordHtmlContent({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: authRecoverPasswordHtmlContentQueryKey(options),
  })
}

/**
 * Recover Password Html Content
 * HTML Content for Password Recovery
 */
export const authRecoverPasswordHtmlContentMutation = (
  options?: Partial<Options<AuthRecoverPasswordHtmlContentData>>,
): UseMutationOptions<
  AuthRecoverPasswordHtmlContentResponse,
  AxiosError<AuthRecoverPasswordHtmlContentError>,
  Options<AuthRecoverPasswordHtmlContentData>
> => {
  const mutationOptions: UseMutationOptions<
    AuthRecoverPasswordHtmlContentResponse,
    AxiosError<AuthRecoverPasswordHtmlContentError>,
    Options<AuthRecoverPasswordHtmlContentData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await authRecoverPasswordHtmlContent({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const usersReadUsersQueryKey = (options?: Options<UsersReadUsersData>) =>
  createQueryKey('usersReadUsers', options)

/**
 * Read Users
 * Retrieve users.
 */
export const usersReadUsersOptions = (
  options?: Options<UsersReadUsersData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await usersReadUsers({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: usersReadUsersQueryKey(options),
  })
}

export const usersCreateUserQueryKey = (
  options: Options<UsersCreateUserData>,
) => createQueryKey('usersCreateUser', options)

/**
 * Create User
 * Create new user.
 */
export const usersCreateUserOptions = (
  options: Options<UsersCreateUserData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await usersCreateUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: usersCreateUserQueryKey(options),
  })
}

/**
 * Create User
 * Create new user.
 */
export const usersCreateUserMutation = (
  options?: Partial<Options<UsersCreateUserData>>,
): UseMutationOptions<
  UsersCreateUserResponse,
  AxiosError<UsersCreateUserError>,
  Options<UsersCreateUserData>
> => {
  const mutationOptions: UseMutationOptions<
    UsersCreateUserResponse,
    AxiosError<UsersCreateUserError>,
    Options<UsersCreateUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await usersCreateUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

/**
 * Delete User Me
 * Delete own user.
 */
export const usersDeleteUserMeMutation = (
  options?: Partial<Options<UsersDeleteUserMeData>>,
): UseMutationOptions<
  UsersDeleteUserMeResponse,
  AxiosError<DefaultError>,
  Options<UsersDeleteUserMeData>
> => {
  const mutationOptions: UseMutationOptions<
    UsersDeleteUserMeResponse,
    AxiosError<DefaultError>,
    Options<UsersDeleteUserMeData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await usersDeleteUserMe({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const usersReadUserMeQueryKey = (
  options?: Options<UsersReadUserMeData>,
) => createQueryKey('usersReadUserMe', options)

/**
 * Read User Me
 * Get current user.
 */
export const usersReadUserMeOptions = (
  options?: Options<UsersReadUserMeData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await usersReadUserMe({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: usersReadUserMeQueryKey(options),
  })
}

/**
 * Update User Me
 * Update own user.
 */
export const usersUpdateUserMeMutation = (
  options?: Partial<Options<UsersUpdateUserMeData>>,
): UseMutationOptions<
  UsersUpdateUserMeResponse,
  AxiosError<UsersUpdateUserMeError>,
  Options<UsersUpdateUserMeData>
> => {
  const mutationOptions: UseMutationOptions<
    UsersUpdateUserMeResponse,
    AxiosError<UsersUpdateUserMeError>,
    Options<UsersUpdateUserMeData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await usersUpdateUserMe({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

/**
 * Update Password Me
 * Update own password.
 */
export const usersUpdatePasswordMeMutation = (
  options?: Partial<Options<UsersUpdatePasswordMeData>>,
): UseMutationOptions<
  UsersUpdatePasswordMeResponse,
  AxiosError<UsersUpdatePasswordMeError>,
  Options<UsersUpdatePasswordMeData>
> => {
  const mutationOptions: UseMutationOptions<
    UsersUpdatePasswordMeResponse,
    AxiosError<UsersUpdatePasswordMeError>,
    Options<UsersUpdatePasswordMeData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await usersUpdatePasswordMe({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const usersRegisterUserQueryKey = (
  options: Options<UsersRegisterUserData>,
) => createQueryKey('usersRegisterUser', options)

/**
 * Register User
 * Create new user without the need to be logged in.
 */
export const usersRegisterUserOptions = (
  options: Options<UsersRegisterUserData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await usersRegisterUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: usersRegisterUserQueryKey(options),
  })
}

/**
 * Register User
 * Create new user without the need to be logged in.
 */
export const usersRegisterUserMutation = (
  options?: Partial<Options<UsersRegisterUserData>>,
): UseMutationOptions<
  UsersRegisterUserResponse,
  AxiosError<UsersRegisterUserError>,
  Options<UsersRegisterUserData>
> => {
  const mutationOptions: UseMutationOptions<
    UsersRegisterUserResponse,
    AxiosError<UsersRegisterUserError>,
    Options<UsersRegisterUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await usersRegisterUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

/**
 * Delete User
 * Delete a user.
 */
export const usersDeleteUserMutation = (
  options?: Partial<Options<UsersDeleteUserData>>,
): UseMutationOptions<
  UsersDeleteUserResponse,
  AxiosError<UsersDeleteUserError>,
  Options<UsersDeleteUserData>
> => {
  const mutationOptions: UseMutationOptions<
    UsersDeleteUserResponse,
    AxiosError<UsersDeleteUserError>,
    Options<UsersDeleteUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await usersDeleteUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const usersReadUserByIdQueryKey = (
  options: Options<UsersReadUserByIdData>,
) => createQueryKey('usersReadUserById', options)

/**
 * Read User By Id
 * Get a specific user by id.
 */
export const usersReadUserByIdOptions = (
  options: Options<UsersReadUserByIdData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await usersReadUserById({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: usersReadUserByIdQueryKey(options),
  })
}

/**
 * Update User
 * Update a user.
 */
export const usersUpdateUserMutation = (
  options?: Partial<Options<UsersUpdateUserData>>,
): UseMutationOptions<
  UsersUpdateUserResponse,
  AxiosError<UsersUpdateUserError>,
  Options<UsersUpdateUserData>
> => {
  const mutationOptions: UseMutationOptions<
    UsersUpdateUserResponse,
    AxiosError<UsersUpdateUserError>,
    Options<UsersUpdateUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await usersUpdateUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const itemsReadItemsQueryKey = (options?: Options<ItemsReadItemsData>) =>
  createQueryKey('itemsReadItems', options)

/**
 * Read Items
 * Retrieve items with pagination, filtering, and sorting.
 *
 * Args:
 * page: Page number (1-based)
 * size: Number of items per page (1-100)
 * search: Search term for title and description
 * sort_by: Field to sort by (title, created_at, updated_at)
 * sort_order: Sort order (asc/desc)
 *
 * Returns:
 * Paginated list of items with metadata
 */
export const itemsReadItemsOptions = (
  options?: Options<ItemsReadItemsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await itemsReadItems({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: itemsReadItemsQueryKey(options),
  })
}

const createInfiniteParams = <
  K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>,
>(
  queryKey: QueryKey<Options>,
  page: K,
) => {
  const params = {
    ...queryKey[0],
  }
  if (page.body) {
    params.body = {
      ...(queryKey[0].body as any),
      ...(page.body as any),
    }
  }
  if (page.headers) {
    params.headers = {
      ...queryKey[0].headers,
      ...page.headers,
    }
  }
  if (page.path) {
    params.path = {
      ...(queryKey[0].path as any),
      ...(page.path as any),
    }
  }
  if (page.query) {
    params.query = {
      ...(queryKey[0].query as any),
      ...(page.query as any),
    }
  }
  return params as unknown as typeof page
}

export const itemsReadItemsInfiniteQueryKey = (
  options?: Options<ItemsReadItemsData>,
): QueryKey<Options<ItemsReadItemsData>> =>
  createQueryKey('itemsReadItems', options, true)

/**
 * Read Items
 * Retrieve items with pagination, filtering, and sorting.
 *
 * Args:
 * page: Page number (1-based)
 * size: Number of items per page (1-100)
 * search: Search term for title and description
 * sort_by: Field to sort by (title, created_at, updated_at)
 * sort_order: Sort order (asc/desc)
 *
 * Returns:
 * Paginated list of items with metadata
 */
export const itemsReadItemsInfiniteOptions = (
  options?: Options<ItemsReadItemsData>,
) => {
  return infiniteQueryOptions<
    ItemsReadItemsResponse,
    AxiosError<ItemsReadItemsError>,
    InfiniteData<ItemsReadItemsResponse>,
    QueryKey<Options<ItemsReadItemsData>>,
    | number
    | Pick<
        QueryKey<Options<ItemsReadItemsData>>[0],
        'body' | 'headers' | 'path' | 'query'
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ItemsReadItemsData>>[0],
          'body' | 'headers' | 'path' | 'query'
        > =
          typeof pageParam === 'object'
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              }
        const params = createInfiniteParams(queryKey, page)
        const { data } = await itemsReadItems({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        })
        return data
      },
      queryKey: itemsReadItemsInfiniteQueryKey(options),
    },
  )
}

export const itemsCreateItemQueryKey = (
  options: Options<ItemsCreateItemData>,
) => createQueryKey('itemsCreateItem', options)

/**
 * Create Item
 * Create new item.
 */
export const itemsCreateItemOptions = (
  options: Options<ItemsCreateItemData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await itemsCreateItem({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: itemsCreateItemQueryKey(options),
  })
}

/**
 * Create Item
 * Create new item.
 */
export const itemsCreateItemMutation = (
  options?: Partial<Options<ItemsCreateItemData>>,
): UseMutationOptions<
  ItemsCreateItemResponse,
  AxiosError<ItemsCreateItemError>,
  Options<ItemsCreateItemData>
> => {
  const mutationOptions: UseMutationOptions<
    ItemsCreateItemResponse,
    AxiosError<ItemsCreateItemError>,
    Options<ItemsCreateItemData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await itemsCreateItem({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

/**
 * Delete Item
 * Delete an item.
 */
export const itemsDeleteItemMutation = (
  options?: Partial<Options<ItemsDeleteItemData>>,
): UseMutationOptions<
  ItemsDeleteItemResponse,
  AxiosError<ItemsDeleteItemError>,
  Options<ItemsDeleteItemData>
> => {
  const mutationOptions: UseMutationOptions<
    ItemsDeleteItemResponse,
    AxiosError<ItemsDeleteItemError>,
    Options<ItemsDeleteItemData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await itemsDeleteItem({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const itemsReadItemQueryKey = (options: Options<ItemsReadItemData>) =>
  createQueryKey('itemsReadItem', options)

/**
 * Read Item
 * Get item by ID.
 */
export const itemsReadItemOptions = (options: Options<ItemsReadItemData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await itemsReadItem({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: itemsReadItemQueryKey(options),
  })
}

/**
 * Update Item
 * Update an item.
 */
export const itemsUpdateItemMutation = (
  options?: Partial<Options<ItemsUpdateItemData>>,
): UseMutationOptions<
  ItemsUpdateItemResponse,
  AxiosError<ItemsUpdateItemError>,
  Options<ItemsUpdateItemData>
> => {
  const mutationOptions: UseMutationOptions<
    ItemsUpdateItemResponse,
    AxiosError<ItemsUpdateItemError>,
    Options<ItemsUpdateItemData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await itemsUpdateItem({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const privateCreateUserQueryKey = (
  options: Options<PrivateCreateUserData>,
) => createQueryKey('privateCreateUser', options)

/**
 * Create User
 * Create a new user.
 */
export const privateCreateUserOptions = (
  options: Options<PrivateCreateUserData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await privateCreateUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: privateCreateUserQueryKey(options),
  })
}

/**
 * Create User
 * Create a new user.
 */
export const privateCreateUserMutation = (
  options?: Partial<Options<PrivateCreateUserData>>,
): UseMutationOptions<
  PrivateCreateUserResponse,
  AxiosError<PrivateCreateUserError>,
  Options<PrivateCreateUserData>
> => {
  const mutationOptions: UseMutationOptions<
    PrivateCreateUserResponse,
    AxiosError<PrivateCreateUserError>,
    Options<PrivateCreateUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await privateCreateUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      })
      return data
    },
  }
  return mutationOptions
}

export const systemHealthCheckQueryKey = (
  options?: Options<SystemHealthCheckData>,
) => createQueryKey('systemHealthCheck', options)

/**
 * Health Check
 */
export const systemHealthCheckOptions = (
  options?: Options<SystemHealthCheckData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await systemHealthCheck({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      })
      return data
    },
    queryKey: systemHealthCheckQueryKey(options),
  })
}
